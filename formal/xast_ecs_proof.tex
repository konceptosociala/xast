\documentclass[14pt,a4paper]{extreport}
\usepackage[left=30mm, right=10mm, top=20mm, bottom=20mm]{geometry}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{pdflscape}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{icomma}
  
\onehalfspacing
\setlength{\parindent}{0cm}
\setlength{\parskip}{0.5em}

\title{\textbf{Xast:} Comparing relational and\\event-driven ECS models}
\author{Oleksandr Hnutov}
\date{\today}

\begin{document}

\maketitle

\section*{Problem}

Dealing with single-entity systems, like
\begin{equation*}
    \mathcal{R} \to \Delta \mathcal{R}, \text{where } \Delta \mathcal{R} \subseteq \mathcal{R},
\end{equation*}
e.g. system, which moves player towards X axis
\begin{equation*}
    \left\{ \text{Player}, \text{Transform} \right\} \to \left\{ \text{Transform} \right\},
\end{equation*}
is straightforward, because both for relational and event-driven systems, formal definition will be the same, so it will have the same properties. We need to define formal definitions for systems, which process 2 and more entities both for the relational ECS model ($\text{System}_{\text{R}}$) and event-driven ECS model ($\text{System}_{\text{E}}$). Systems in the event-driven model are restricted to single-pass iteration over the event sequence and may not construct auxiliary indices whose size depends on $|\operatorname{Seq}(\text{Event})|$.

As an example, we will consider a simple system with two entities:
\begin{align*}
    \text{\textbf{EnemyFollowPlayer}}&\colon\space\\
        &\left\{ \text{Player}, \text{Transform} \right\},\\
        &\left\{ \text{Enemy}, \text{Transform} \right\}\\
        &\to \left\{ \text{Enemy, Transform} \right\}.
\end{align*}

\section*{Formal definition}

\begin{equation*}
    \text{System}_{\text{R}} \colon \mathcal{R}_1 \times \mathcal{R}_2 \times \dots \times \mathcal{R}_n \to \Delta \mathcal{R},
\end{equation*}
where:
\begin{enumerate}\itemsep=0pt
    \item $\mathcal{R}_i$ is a set of entities with a component set $C_i$,
    \item $\Delta \mathcal{R}$ denotes a finite set of component updates applied to entities in $\mathcal{R}$.
\end{enumerate}

\begin{equation*}
    \text{System}_{\text{E}} \colon \mathcal{R} \times \operatorname{Seq}(\text{Event}) \to \Delta \mathcal{R},
\end{equation*}
where:
\begin{enumerate}\itemsep=0pt
    \item Event is a finite set of components $C$;
    \item $\operatorname{Seq}(\text{Event})$ denotes an ordered sequence, allowing only sequential access.
\end{enumerate}

Let $E$ be the set of enemies entities and $P$ the set of players entities. Let $n = |E|$ and $m = |P|$.\\
Let $f\colon \text{Transform} \times \text{Transform} \to \text{Transform}$ be a pure function, which computes the next enemy position, moving to a player, based on player's and enemy's positions.\\
Let $\operatorname{\textbf{choose}}(P, e)$ be a deterministic selection function from players for any enemy.

Relational model system will be
\begin{align*}
    \text{System}_{\text{R}}&\colon \space \forall e \in E\colon\\
        &\text{targetP} = \operatorname{\textbf{choose}}(P, e)\\
        &e.\text{Transform} = f(e.\text{Transform}, \text{targetP}.\text{Transform});
\end{align*}

If $\operatorname{\textbf{choose}}$ is $\operatorname{O}(1)$ (e.g., the \textbf{lookupMap} function on a precomputed map), total complexity will be the following:
\begin{equation*}
    T_\text{R} = \text{O}(n+m);
\end{equation*}

In worst case, if $\operatorname{\textbf{choose}}$ need to scan all the players, total complexity will be
\begin{equation*}
    T_\text{R} = \text{O}(n \cdot m).
\end{equation*}

Let Event be a tuple: $(\text{Player}, \text{Transform})$.
Event-driven model system will be
\begin{align*}
    \text{System}_{\text{E}} \colon \space \forall e &\in E\colon\\
        &\forall \mathtt{ev} \in \operatorname{Seq}(\text{Event})\\
            &\phantom{\forall k \in {}}e.\text{Transform} = f(e.\text{Transform}, \mathtt{ev}.\text{Transform});
\end{align*}

So we every time we will scan the entire sequence of events, so total complexity is
\begin{equation*}
    T_\text{E} = \text{O}(n \cdot m).
\end{equation*}

\section*{Theorem. Lower bound for event-driven ECS}
Let $E$ be a set of $n$ enemy entities and $P$ a set of $m$ player entities.
Assume a system processes enemies by iterating over a linear sequence of
events $\operatorname{Seq}(P)$ and has no auxiliary indexing structure.
Then any system computing a function
\begin{equation*}
f : E \times P \to \Delta E
\end{equation*}
has worst-case time complexity $\Omega(n \cdot m)$.

\section*{Proof}
Let $\operatorname{Seq}(P)$ be a sequence containing exactly one event for each player.
By assumption, the system can only access player data by iterating through
$\operatorname{Seq}(P)$.

For a fixed enemy $e \in E$, any algorithm that depends on player data must,
in the worst case, inspect all $m$ events to determine the relevant player
(e.g. nearest player, target selection).

Thus, processing a single enemy requires $\Omega(m)$ time.

Since the system processes all $n$ enemies independently, the total worst-case
time complexity is $\Omega(n \cdot m)$.

\end{document}
